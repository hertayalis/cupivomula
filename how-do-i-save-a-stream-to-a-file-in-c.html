<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=description content="I have a StreamReader object that I initialized with a stream, now I want to save this stream to disk (the stream may be a .gif or .jpg or .pdf). Existing Code: I have the encoding type also, which I will need if I store it to SQL Server, correct?"><meta name=generator content="Hugo 0.98.0"><meta name=robots content="index,follow,noarchive"><title>How do I save a stream to a file in C#? &#183;</title><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/pure-min.css><!--[if lte IE 8]><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/grids-responsive-old-ie-min.css><![endif]--><!--[if gt IE 8]><!--><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/grids-responsive-min.css><!--<![endif]--><!--[if lte IE 8]><link rel=stylesheet href=https://assets.cdnweb.info/hugo/blackburn/css/side-menu-old-ie.css><![endif]--><!--[if gt IE 8]><!--><link rel=stylesheet href=https://assets.cdnweb.info/hugo/blackburn/css/side-menu.css><!--<![endif]--><link rel=stylesheet href=https://assets.cdnweb.info/hugo/blackburn/css/blackburn.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css><link rel=preconnect href=https://fonts.gstatic.com><link href="https://fonts.googleapis.com/css2?family=Raleway&display=swap" rel=stylesheet type=text/css><script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<link rel=stylesheet href=//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.6.0/styles/androidstudio.min.css><script async src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.6.0/highlight.min.js></script>
<script>hljs.initHighlightingOnLoad()</script><link rel="shortcut icon" href=./img/favicon.ico type=image/x-icon></head><body><div id=layout><a href=#menu id=menuLink class=menu-link><span></span></a><div id=menu><a class="pure-menu-heading brand" href=./index.html>PulseBlog</a><div class=pure-menu><ul class=pure-menu-list><li class=pure-menu-item><a class=pure-menu-link href=./index.html><i class="fa fa-home fa-fw"></i>Home</a></li><li class=pure-menu-item><a class=pure-menu-link href=./post/index.html><i class="fa fa-list fa-fw"></i>Posts</a></li><li class=pure-menu-item><a class=pure-menu-link href=./sitemap.xml><i class="fa fa-user fa-fw"></i>Sitemap</a></li><li class=pure-menu-item><a class=pure-menu-link href=./index.xml><i class="fa fa-phone fa-fw"></i>RSS</a></li></ul></div><div class="pure-menu social"><ul class=pure-menu-list></ul></div><div><div class=small-print><small>&copy; 2022. All rights reserved.</small></div><div class=small-print><small>Built with&nbsp;<a href=https://gohugo.io/ target=_blank>Hugo</a></small>
<small>Theme&nbsp;<a href=https://github.com/yoshiharuyamashita/blackburn target=_blank>Blackburn</a></small></div></div></div><div id=main><div class=header><h1>How do I save a stream to a file in C#?</h1><h2>I have a StreamReader object that I initialized with a stream, now I want to save this stream to disk (the stream may be a .gif or .jpg or .pdf). Existing Code: I have the encoding type also, which I will need if I store it to SQL Server, correct?</h2></div><div class=content><div class=post-meta><div><i class="fa fa-calendar fa-fw"></i>
<time>06 Jun 2024, 00:00</time></div></div><img src=https://cdn.statically.io/img/cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto><p>I have a <code>StreamReader</code> object that I initialized with a stream, now I want to save this stream to disk (the stream may be a <code>.gif</code> or <code>.jpg</code> or <code>.pdf</code>).</p><p>Existing Code:</p><pre><code>StreamReader sr = new StreamReader(myOtherObject.InputStream); </code></pre><li>I need to save this to disk (I have the filename).</li><li>In the future I may want to store this to SQL Server.</li><p>I have the encoding type also, which I will need if I store it to SQL Server, correct?</p><span class=d-none itemprop=commentCount>1</span><h2 class=mb0 data-answercount=10>10 Answers</h2><p>As highlighted by Tilendor in Jon Skeet's answer, streams have a <code>CopyTo</code> method since .NET 4.</p><pre><code>var fileStream = File.Create("C:\\Path\\To\\File"); myOtherObject.InputStream.Seek(0, SeekOrigin.Begin); myOtherObject.InputStream.CopyTo(fileStream); fileStream.Close(); </code></pre><p>Or with the <code>using</code> syntax:</p><pre><code>using (var fileStream = File.Create("C:\\Path\\To\\File")) { myOtherObject.InputStream.Seek(0, SeekOrigin.Begin); myOtherObject.InputStream.CopyTo(fileStream); } </code></pre><span class=d-none itemprop=commentCount>7</span><p>You must not use <code>StreamReader</code> for binary files (like gifs or jpgs). <code>StreamReader</code> is for text data. You will almost certainly lose data if you use it for arbitrary binary data. (If you use Encoding.GetEncoding(28591) you will probably be okay, but what's the point?)</p><p>Why do you need to use a <code>StreamReader</code> at all? Why not just keep the binary data as binary data and write it back to disk (or SQL) as binary data?</p><p>EDIT: As this seems to be something people want to see... if you do just want to copy one stream to another (e.g. to a file) use something like this:</p><pre><code>/// &lt;summary&gt; /// Copies the contents of input to output. Doesn't close either stream. /// &lt;/summary&gt; public static void CopyStream(Stream input, Stream output) { byte[] buffer = new byte[8 * 1024]; int len; while ( (len = input.Read(buffer, 0, buffer.Length)) &gt; 0) { output.Write(buffer, 0, len); } } </code></pre><p>To use it to dump a stream to a file, for example:</p><pre><code>using (Stream file = File.Create(filename)) { CopyStream(input, file); } </code></pre><p>Note that <a href=# rel=noreferrer><code>Stream.CopyTo</code></a> was introduced in .NET 4, serving basically the same purpose.</p><span class=d-none itemprop=commentCount>8</span><pre><code>public void CopyStream(Stream stream, string destPath) { using (var fileStream = new FileStream(destPath, FileMode.Create, FileAccess.Write)) { stream.CopyTo(fileStream); } } </code></pre><span class=d-none itemprop=commentCount>4</span><pre><code>private void SaveFileStream(String path, Stream stream) { var fileStream = new FileStream(path, FileMode.Create, FileAccess.Write); stream.CopyTo(fileStream); fileStream.Dispose(); } </code></pre><span class=d-none itemprop=commentCount>3</span><p>I don't get all of the answers using <code>CopyTo</code>, where maybe the systems using the app might not have been upgraded to .NET 4.0+. I know some would like to force people to upgrade, but compatibility is also nice, too.</p><p>Another thing, I don't get using a stream to copy from another stream in the first place. Why not just do:</p><pre><code>byte[] bytes = myOtherObject.InputStream.ToArray(); </code></pre><p>Once you have the bytes, you can easily write them to a file:</p><pre><code>public static void WriteFile(string fileName, byte[] bytes) { string path = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location); if (!path.EndsWith(@"\")) path += @"\"; if (File.Exists(Path.Combine(path, fileName))) File.Delete(Path.Combine(path, fileName)); using (FileStream fs = new FileStream(Path.Combine(path, fileName), FileMode.CreateNew, FileAccess.Write)) { fs.Write(bytes, 0, (int)bytes.Length); //fs.Close(); } } </code></pre><p>This code works as I've tested it with a <code>.jpg</code> file, though I admit I have only used it with small files (less than 1 MB). One stream, no copying between streams, no encoding needed, just write the bytes! No need to over-complicate things with <code>StreamReader</code> if you already have a stream you can convert to <code>bytes</code> directly with <code>.ToArray()</code>!</p><p>Only potential downsides I can see in doing it this way is if there's a large file you have, having it as a stream and using <code>.CopyTo()</code> or equivalent allows <code>FileStream</code> to stream it instead of using a byte array and reading the bytes one by one. It might be slower doing it this way, as a result. But it shouldn't choke since the <code>.Write()</code> method of the <code>FileStream</code> handles writing the bytes, and it's only doing it one byte at a time, so it won't clog memory, except that <strong>you will have to have enough memory to hold the stream as a <code>byte[]</code> object</strong>. In my situation where I used this, getting an <code>OracleBlob</code>, I had to go to a <code>byte[]</code>, it was small enough, and besides, there was no streaming available to me, anyway, so I just sent my bytes to my function, above.</p><p>Another option, using a stream, would be to use it with Jon Skeet's <code>CopyStream</code> function that was in another post - this just uses <code>FileStream</code> to take the input stream and create the file from it directly. It does not use <code>File.Create</code>, like he did (which initially seemed to be problematic for me, but later found it was likely just a VS bug...).</p><pre><code>/// &lt;summary&gt; /// Copies the contents of input to output. Doesn't close either stream. /// &lt;/summary&gt; public static void CopyStream(Stream input, Stream output) { byte[] buffer = new byte[8 * 1024]; int len; while ( (len = input.Read(buffer, 0, buffer.Length)) &gt; 0) { output.Write(buffer, 0, len); } } public static void WriteFile(string fileName, Stream inputStream) { string path = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location); if (!path.EndsWith(@"\")) path += @"\"; if (File.Exists(Path.Combine(path, fileName))) File.Delete(Path.Combine(path, fileName)); using (FileStream fs = new FileStream(Path.Combine(path, fileName), FileMode.CreateNew, FileAccess.Write) { CopyStream(inputStream, fs); } inputStream.Close(); inputStream.Flush(); } </code></pre><span class=d-none itemprop=commentCount>4</span><p>Here's an example that uses proper usings and implementation of idisposable:</p><pre><code>static void WriteToFile(string sourceFile, string destinationfile, bool append = true, int bufferSize = 4096) { using (var sourceFileStream = new FileStream(sourceFile, FileMode.OpenOrCreate)) { using (var destinationFileStream = new FileStream(destinationfile, FileMode.OpenOrCreate)) { while (sourceFileStream.Position &lt; sourceFileStream.Length) { destinationFileStream.WriteByte((byte)sourceFileStream.ReadByte()); } } } } </code></pre><p>...and there's also this</p><pre><code> public static void WriteToFile(Stream stream, string destinationFile, int bufferSize = 4096, FileMode mode = FileMode.OpenOrCreate, FileAccess access = FileAccess.ReadWrite, FileShare share = FileShare.ReadWrite) { using (var destinationFileStream = new FileStream(destinationFile, mode, access, share)) { while (stream.Position &lt; stream.Length) { destinationFileStream.WriteByte((byte)stream.ReadByte()); } } } </code></pre><p>The key is understanding the proper use of using (which should be implemented on the instantiation of the object that implements idisposable as shown above), and having a good idea as to how the properties work for streams. Position is literally the index within the stream (which starts at 0) that is followed as each byte is read using the readbyte method. In this case I am essentially using it in place of a for loop variable and simply letting it follow through all the way up to the length which is LITERALLY the end of the entire stream (in bytes). Ignore in bytes because it is practically the same and you will have something simple and elegant like this that resolves everything cleanly.</p><p>Keep in mind, too, that the ReadByte method simply casts the byte to an int in the process and can simply be converted back.</p><p>I'm gonna add another implementation I recently wrote to create a dynamic buffer of sorts to ensure sequential data writes to prevent massive overload</p><pre><code>private void StreamBuffer(Stream stream, int buffer) { using (var memoryStream = new MemoryStream()) { stream.CopyTo(memoryStream); var memoryBuffer = memoryStream.GetBuffer(); for (int i = 0; i &lt; memoryBuffer.Length;) { var networkBuffer = new byte[buffer]; for (int j = 0; j &lt; networkBuffer.Length &amp;&amp; i &lt; memoryBuffer.Length; j++) { networkBuffer[j] = memoryBuffer[i]; i++; } //Assuming destination file destinationFileStream.Write(networkBuffer, 0, networkBuffer.Length); } } } </code></pre><p>The explanation is fairly simple: we know that we need to keep in mind the entire set of data we wish to write and also that we only want to write certain amounts, so we want the first loop with the last parameter empty (same as while). Next, we initialize a byte array buffer that is set to the size of what's passed, and with the second loop we compare j to the size of the buffer and the size of the original one, and if it's greater than the size of the original byte array, end the run.</p><span class=d-none itemprop=commentCount>1</span><p>Why not use a FileStream object?</p><pre><code>public void SaveStreamToFile(string fileFullPath, Stream stream) { if (stream.Length == 0) return; // Create a FileStream object to write a stream to a file using (FileStream fileStream = System.IO.File.Create(fileFullPath, (int)stream.Length)) { // Fill the bytes[] array with the stream data byte[] bytesInStream = new byte[stream.Length]; stream.Read(bytesInStream, 0, (int)bytesInStream.Length); // Use FileStream object to write to the specified file fileStream.Write(bytesInStream, 0, bytesInStream.Length); } } </code></pre><span class=d-none itemprop=commentCount>4</span><pre><code>//If you don't have .Net 4.0 :) public void SaveStreamToFile(Stream stream, string filename) { using(Stream destination = File.Create(filename)) Write(stream, destination); } //Typically I implement this Write method as a Stream extension method. //The framework handles buffering. public void Write(Stream from, Stream to) { for(int a = from.ReadByte(); a != -1; a = from.ReadByte()) to.WriteByte( (byte) a ); } /* Note, StreamReader is an IEnumerable&lt;Char&gt; while Stream is an IEnumbable&lt;byte&gt;. The distinction is significant such as in multiple byte character encodings like Unicode used in .Net where Char is one or more bytes (byte[n]). Also, the resulting translation from IEnumerable&lt;byte&gt; to IEnumerable&lt;Char&gt; can loose bytes or insert them (for example, "\n" vs. "\r\n") depending on the StreamReader instance CurrentEncoding. */ </code></pre><span class=d-none itemprop=commentCount>1</span><p>Another option is to get the stream to a <code>byte[]</code> and use <code>File.WriteAllBytes</code>. This should do:</p><pre><code>using (var stream = new MemoryStream()) { input.CopyTo(stream); File.WriteAllBytes(file, stream.ToArray()); } </code></pre><p>Wrapping it in an extension method gives it better naming:</p><pre><code>public void WriteTo(this Stream input, string file) { //your fav write method: using (var stream = File.Create(file)) { input.CopyTo(stream); } //or using (var stream = new MemoryStream()) { input.CopyTo(stream); File.WriteAllBytes(file, stream.ToArray()); } //whatever that fits. } </code></pre><span class=d-none itemprop=commentCount>1</span><pre><code>public void testdownload(stream input) { byte[] buffer = new byte[16345]; using (FileStream fs = new FileStream(this.FullLocalFilePath, FileMode.Create, FileAccess.Write, FileShare.None)) { int read; while ((read = input.Read(buffer, 0, buffer.Length)) &gt; 0) { fs.Write(buffer, 0, read); } } } </code></pre><span class=d-none itemprop=commentCount>2</span><p class=postsid style=color:rgba(255,0,0,0)>ncG1vNJzZmirpJawrLvVnqmfpJ%2Bse6S7zGiorp2jqbawutJoa2ppZW5%2FcLTOsGSdp12eerSt1Z5kmmWjqb%2Bmrcxmq6hlkWKzqrjEZqCnZZM%3D</p><h4><i class="fas fa-share-alt" aria-hidden=true></i>&nbsp;Share!</h4><ul class=share-buttons><li><a href="https://www.facebook.com/sharer/sharer.php?u=%2fhow-do-i-save-a-stream-to-a-file-in-c.html" target=_blank title="Share on Facebook"><i class="fab fa-facebook" aria-hidden=true></i><span class=sr-only>Share on Facebook</span></a></li>&nbsp;&nbsp;&nbsp;<li><a href="https://twitter.com/intent/tweet?source=%2fhow-do-i-save-a-stream-to-a-file-in-c.html" target=_blank title=Tweet><i class="fab fa-twitter" aria-hidden=true></i><span class=sr-only>Tweet</span></a></li>&nbsp;&nbsp;&nbsp;<li><a href="https://plus.google.com/share?url=%2fhow-do-i-save-a-stream-to-a-file-in-c.html" target=_blank title="Share on Google+"><i class="fab fa-google-plus" aria-hidden=true></i><span class=sr-only>Share on Google+</span></a></li>&nbsp;&nbsp;&nbsp;<li><a href="http://www.tumblr.com/share?v=3&u=%2fhow-do-i-save-a-stream-to-a-file-in-c.html" target=_blank title="Post to Tumblr"><i class="fab fa-tumblr" aria-hidden=true></i><span class=sr-only>Post to Tumblr</span></a></li>&nbsp;&nbsp;&nbsp;<li><a href="http://pinterest.com/pin/create/button/?url=%2fhow-do-i-save-a-stream-to-a-file-in-c.html" target=_blank title="Pin it"><i class="fab fa-pinterest-p" aria-hidden=true></i><span class=sr-only>Pin it</span></a></li>&nbsp;&nbsp;&nbsp;<li><a href="http://www.reddit.com/submit?url=%2fhow-do-i-save-a-stream-to-a-file-in-c.html" target=_blank title="Submit to Reddit"><i class="fab fa-reddit-alien" aria-hidden=true></i><span class=sr-only>Submit to Reddit</span></a></li></ul><style>ul.share-buttons{list-style:none;padding:0}ul.share-buttons li{display:inline}ul.share-buttons .sr-only{position:absolute;clip:rect(1px 1px 1px 1px);clip:rect(1px,1px,1px,1px);padding:0;border:0;height:1px;width:1px;overflow:hidden}</style><div class="prev-next-post pure-g"><div class=pure-u-1-24 style=text-align:left><a href=./joe-rogans-dad-claims-money-went-to-his-head-as-spotify-futures-questioned-after-jewish-comments.html><i class="fa fa-chevron-left"></i></a></div><div class=pure-u-10-24><nav class=prev><a href=./joe-rogans-dad-claims-money-went-to-his-head-as-spotify-futures-questioned-after-jewish-comments.html>Joe Rogan's dad claims 'money went to his head' as Spotify future's questioned after Jewish comments</a></nav></div><div class=pure-u-2-24>&nbsp;</div><div class=pure-u-10-24><nav class=next><a href=./arzo-anwar-net-worth-278308.html>Arzo Anwar Net Worth</a></nav></div><div class=pure-u-1-24 style=text-align:right><a href=./arzo-anwar-net-worth-278308.html><i class="fa fa-chevron-right"></i></a></div></div></div></div></div><script src=https://assets.cdnweb.info/hugo/blackburn/js/ui.js></script>
<script src=https://assets.cdnweb.info/hugo/blackburn/js/menus.js></script>
<script src=./js/math-code.js></script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script type=text/javascript>(function(){var n=Math.floor(Date.now()/1e3),t=document.getElementsByTagName("script")[0],e=document.createElement("script");e.src="https://iklan.listspress.com/floating.js?v="+n+"",e.type="text/javascript",e.async=!0,e.defer=!0,t.parentNode.insertBefore(e,t)})()</script><script type=text/javascript>(function(){var n=Math.floor(Date.now()/1e3),t=document.getElementsByTagName("script")[0],e=document.createElement("script");e.src="https://iklan.listspress.com/tracking_server_6.js?v="+n+"",e.type="text/javascript",e.async=!0,e.defer=!0,t.parentNode.insertBefore(e,t)})()</script><script>var _paq=window._paq=window._paq||[];_paq.push(["trackPageView"]),_paq.push(["enableLinkTracking"]),function(){e="//analytics.cdnweb.info/",_paq.push(["setTrackerUrl",e+"matomo.php"]),_paq.push(["setSiteId","1"]);var e,n=document,t=n.createElement("script"),s=n.getElementsByTagName("script")[0];t.async=!0,t.src=e+"matomo.js",s.parentNode.insertBefore(t,s)}()</script></body></html>